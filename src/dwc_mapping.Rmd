---
title: "Mapping to Darwin Core"
author: "Peter Desmet & Quentin Groom"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

This document describes how we've mapped the checklist data to Darwin Core.

## Setup

Set locale (so we use UTF-8 character encoding):

```{r set_locale}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_ALL", 'en_US.UTF-8')
```

Load libraries:

```{r load_libraries}
library(tidyverse)
library(readxl) # Not part of core tidyverse
library(janitor)
library(pander)
```

Set file paths:

```{r set_file_paths}
# All paths should be relative to this script
input_checklist_file = "../data/raw/Checklist2.xls"
lookup_file = "../settings/lookup.csv"
output_taxon_file = "../data/processed/taxon.csv"
output_distribution_file = "../data/processed/distribution.csv"
output_description_file = "../data/processed/description.csv"
```

Create term lookup function:

```{r lookup_function}
term_lookup <- function(lookup_table, term) {
  # Filter lookup table on term (expected to be first column)
  
  # Unfortunately we cannot pass 'term' as a variable to 
  # filter(lookup_table[[1]] == term)
  # So, we need to create the condition as a string and pass to filter_()
  condition <- paste0(colnames(lookup_table)[[1]], "==\"", term, "\"")
  # e.g. 'term == "locationID"'
  lookup_table %>%
  filter_(condition) -> term_lookup_table
  
  # Throw error if filter returns no results
  if (nrow(term_lookup_table) == 0) stop(paste0("Term \"", term, "\" not found in first column of lookup table."))
  
  # Create list with new values (expected to be 3rd column) as values
  lookup_vector <- as.vector(term_lookup_table[[3]])
  # And lookup values (expected to be 2nd column) as names
  lookup_vector <- setNames(lookup_vector, term_lookup_table[[2]])
  
  return(lookup_vector)
}
```

Read lookup file:

```{r lookup_file}
lookup_table <- read.csv(lookup_file)
```

## Read data

Read the source checklist (an Excel file):

```{r read_excel}
read_excel(
  path = input_checklist_file,
  skip = 1 # First row is empty
) -> checklist
```

Remove empty rows and process the "Presence" subheaders `Fl.`, `Br.`, `Wa.`:

```{r handle_empty_rows}
checklist %>%
# Remove empty rows
remove_empty_rows() %>%

# The first row contains subheaders for "Presence": Fl., Br., Wa.
# So, we'll rename to actual headers to keep this information
rename(Presence_Fl = Presence, Presence_Br = X__1, Presence_Wa = X__2) %>%
  
# That first row can now be removed, by slicing from 2 till the end
slice(2:(n())) -> checklist
```

Add row number as an identifier (`ID`) and save the column names for future reference:

```{r add_id_store_colnames}
# Add ID as first column
checklist <- cbind("ID" = seq.int(nrow(checklist)), checklist)

# Save column names
checklist_colnames <- colnames(checklist)
```

Preview data:

```{r head_checklist}
pander(head(checklist))
```

## Create taxon core

Map the source data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml):

```{r taxon_mapping}
checklist %>%
mutate(
  id = ID,
  # modified
  language = "en",
  license = "http://creativecommons.org/publicdomain/zero/1.0/",
  rightsHolder = "Botanic Garden Meise",
  # accessRights
  # bibliographicCitation
  # informationWithheld
  datasetID = "", # Should become the DOI
  datasetName = "Manual of the Alien Plants of Belgium", 
  # references
  taxonID = ID,
  # scientificNameID
  # acceptedNameUsageID
  # parentNameUsageID
  # originalNameUsageID
  # nameAccordingToID
  # namePublishedInID
  # taxonConceptID
  scientificName = Taxon,
  # acceptedNameUsage
  # parentNameUsage
  # originalNameUsage
  # nameAccordingTo
  # namePublishedIn
  # namePublishedInYear
  # higherClassification
  kingdom = "Plantae",
  # phylum
  # class
  # order
  family = Family,
  # genus
  # subgenus
  # specificEpithet
  # infraspecificEpithet
  # taxonRank
  # verbatimTaxonRank
  # scientificNameAuthorship
  # vernacularName
  nomenclaturalCode = "ICBN"
  # taxonomicStatus
  # nomenclaturalStatus
  # taxonRemarks
) %>%
  
# Remove the original columns
select(-one_of(checklist_colnames)) -> taxon

# Preview data
pander(head(taxon))
```

Save to CSV:

```{r save_taxon_csv}
write.csv(taxon, file = output_taxon_file, na = "", row.names = FALSE)
```

## Create distribution extension

Create a `Presence_Be` column, which contains `X` if any of the regions has `X` and if not has `?` if any of the regions has `?`:

```{r add_presence_be}
checklist %>%
mutate(Presence_Be = case_when(
  .$Presence_Fl == "X" | .$Presence_Br == "X" | .$Presence_Wa == "X" ~ "X",
  .$Presence_Fl == "?" | .$Presence_Br == "?" | .$Presence_Wa == "?" ~ "?")
) -> distribution
```

Create records for each value in the four presence columns but not for `NA` values:

```{r create_distribution_records}
distribution %>%
gather(
  presence_area, presence_value,
  Presence_Be, Presence_Br, Presence_Fl, Presence_Wa,
  na.rm = TRUE,
  convert = FALSE
) %>%

# Sort on ID
arrange(ID) -> distribution
```

Map the source data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml):

```{r distribution_mapping}
distribution %>%
mutate(
  id = ID,
  locationID = paste0(
    "ISO3166-2:",
    recode(.$presence_area, !!!term_lookup(lookup_table, "locationID"))
  ),
  locality = recode(.$presence_area, !!!term_lookup(lookup_table, "locality")),
  countryCode = "BE",
  # lifeStage
  occurrenceStatus = case_when(
    .$presence_value == "X" ~ "present",
    .$presence_value == "?" ~ "unknown"
  )
  # threatStatus
  # establishmentMeans
  # appendixCITES
  # eventDate
  # startDayOfYear
  # endDayOfYear
  # source
  # occurrenceRemarks
  # datasetID
) %>%
  
# Remove the original columns + the two presence ones
select(-one_of(checklist_colnames), -presence_area, -presence_value) -> distribution

# Preview data
pander(head(distribution))
```

Save to CSV:

```{r save_distribution_csv}
write.csv(distribution, file = output_distribution_file, na = "", row.names = FALSE)
```
