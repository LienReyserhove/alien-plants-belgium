---
title: "Mapping to Darwin Core"
author: "Peter Desmet & Quentin Groom"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

This document describes how we've mapped the checklist data to Darwin Core.

## Setup

Set locale (so we use UTF-8 character encoding):

```{r set_locale}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_ALL", 'en_US.UTF-8')
```

Load libraries:

```{r load_libraries}
library(tidyverse)
library(readxl) # Not part of core tidyverse
library(janitor)
library(pander)
```

Set file paths:

```{r set_file_paths}
# All paths should be relative to this script
input_checklist_file = "../data/raw/Checklist2.xls"
lookup_file = "../settings/lookup.csv"
output_taxon_file = "../data/processed/taxon.csv"
output_distribution_file = "../data/processed/distribution.csv"
output_description_file = "../data/processed/description.csv"
```

Create term lookup function:

```{r lookup_function}
term_lookup <- function(lookup_table, term) {
  # Filter lookup table on term (expected to be first column)
  
  # Unfortunately we cannot pass 'term' as a variable to 
  # filter(lookup_table[[1]] == term)
  # So, we need to create the condition as a string and pass to filter_()
  condition <- paste0(colnames(lookup_table)[[1]], "==\"", term, "\"")
  # e.g. 'term == "locationID"'
  lookup_table %>%
  filter_(condition) -> term_lookup_table
  
  # Throw error if filter returns no results
  if (nrow(term_lookup_table) == 0) stop(paste0("Term \"", term, "\" not found in first column of lookup table."))
  
  # Create list with new values (expected to be 3rd column) as values
  lookup_vector <- as.vector(term_lookup_table[[3]])
  # And lookup values (expected to be 2nd column) as names
  lookup_vector <- setNames(lookup_vector, term_lookup_table[[2]])
  
  return(lookup_vector)
}
```

Read lookup file:

```{r lookup_file}
lookup_table <- read.csv(lookup_file)
```

## Read data

Read the source checklist (an Excel file):

```{r read_excel}
read_excel(
  path = input_checklist_file,
  skip = 1 # First row is empty
) -> checklist
```

Remove empty rows and process the "Presence" subheaders `Fl.`, `Br.`, `Wa.`:

```{r handle_empty_rows}
checklist %>%
# Remove empty rows
remove_empty_rows() %>%

# Have sensible (lowercase) column names
clean_names() %>%

# The first row contains subheaders for "presence": Fl., Br., Wa.
# So, we'll rename to actual headers to keep this information
rename(presence_fl = presence, presence_br = x_1, presence_wa = x_2) %>%

# That first row can now be removed, by slicing from 2 till the end
slice(2:(n())) -> checklist
```

Add row number as an identifier (`id`):

```{r add_id}
# Add ID as first column
checklist <- cbind("id" = seq.int(nrow(checklist)), checklist)
```

Add prefix `_raw` to all column names to avoid name clashes with Darwin Core terms and save those column names as a list (so these can be removed easily later):

```{r add_colname_prefix}
colnames(checklist) <- paste0("raw_", colnames(checklist))

# Save column names
raw_colnames <- colnames(checklist)
```

Preview data:

```{r head_checklist}
pander(head(checklist))
```

## Create taxon core

Map the source data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml):

```{r taxon_mapping}
checklist %>%
mutate(
  id = raw_id,
  # modified
  language = "en",
  license = "http://creativecommons.org/publicdomain/zero/1.0/",
  rightsHolder = "Botanic Garden Meise",
  # accessRights
  # bibliographicCitation
  # informationWithheld
  datasetID = "", # Should become the DOI
  datasetName = "Manual of the Alien Plants of Belgium", 
  # references
  taxonID = raw_id,
  # scientificNameID
  # acceptedNameUsageID
  # parentNameUsageID
  # originalNameUsageID
  # nameAccordingToID
  # namePublishedInID
  # taxonConceptID
  scientificName = raw_taxon,
  # acceptedNameUsage
  # parentNameUsage
  # originalNameUsage
  # nameAccordingTo
  # namePublishedIn
  # namePublishedInYear
  # higherClassification
  kingdom = "Plantae",
  # phylum
  # class
  # order
  family = raw_family,
  # genus
  # subgenus
  # specificEpithet
  # infraspecificEpithet
  # taxonRank
  # verbatimTaxonRank
  # scientificNameAuthorship
  # vernacularName
  nomenclaturalCode = "ICBN"
  # taxonomicStatus
  # nomenclaturalStatus
  # taxonRemarks
) %>%
  
# Remove the original columns
select(-one_of(raw_colnames)) -> taxon

# Preview data
pander(head(taxon))
```

Save to CSV:

```{r save_taxon_csv}
write.csv(taxon, file = output_taxon_file, na = "", row.names = FALSE)
```

## Create distribution extension

Create a `raw_presence_be` column, which contains `X` if any of the regions has `X` and if not has `?` if any of the regions has `?`:

```{r add_presence_be}
checklist %>%
mutate(raw_presence_be = case_when(
  .$raw_presence_fl == "X" | .$raw_presence_br == "X" | .$raw_presence_wa == "X" ~ "X",
  .$raw_presence_fl == "?" | .$raw_presence_br == "?" | .$raw_presence_wa == "?" ~ "?")
) -> distribution
```

Create records for each value in the four presence columns but not for `NA` values:

```{r create_distribution_records}
distribution %>%
gather(
  raw_presence_region, raw_presence_value,
  raw_presence_be, raw_presence_br, raw_presence_fl, raw_presence_wa,
  na.rm = TRUE,
  convert = FALSE
) %>%

# Sort on ID
arrange(raw_id) -> distribution
```

Map the source data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml):

```{r distribution_mapping}
distribution %>%
mutate(
  id = raw_id,
  locationID = paste0(
    "ISO3166-2:",
    recode(.$raw_presence_region, !!!term_lookup(lookup_table, "locationID"))
  ),
  locality = recode(.$raw_presence_region, !!!term_lookup(lookup_table, "locality")),
  countryCode = "BE",
  # lifeStage
  occurrenceStatus = case_when(
    .$raw_presence_value == "X" ~ "present",
    .$raw_presence_value == "?" ~ "unknown"
  )
  # threatStatus
  # establishmentMeans
  # appendixCITES
  # eventDate
  # startDayOfYear
  # endDayOfYear
  # source
  # occurrenceRemarks
  # datasetID
) %>%
  
# Remove the original columns + the two presence ones
select(-one_of(raw_colnames), -raw_presence_region, -raw_presence_value) -> distribution

# Preview data
pander(head(distribution))
```

Save to CSV:

```{r save_distribution_csv}
write.csv(distribution, file = output_distribution_file, na = "", row.names = FALSE)
```
